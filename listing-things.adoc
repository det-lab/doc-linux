= Navigating the file system
:toc: left
:experimental:
:commandkey: &#8984;
:optionkey: &#8997;
:shiftkey: &#x21e7;
:imagesdir: /Users/eljefe/Det-Lab-Doc/unix-tut




=== listing files

`*ls*`(list storage) allows you to view a directory's content. While in your home directory, type 

```sh
$ ls
```

=== Current directory (.) and parent directory (..)


As you can see, there are two directories called (*.*) and (*..*).

(*.*) means the current directory, so typing

```sh
$ ls .
```

has the same effect as runing *`ls`* by itself. 

However, by adding the parent directory (*..*) allows us to peak  inside the directory that contains our home directory. 

```sh
$ ls ..
```

=== Unix-like filesystem

To get a better idea of what we're dealing with, take a look at the image below. It's called a tree (more like an upside down tree), and it represents the basic structure of all Unix-like filesystems. 

// insert image

All files and directories are contained withing the root directory, represented by a forward slash (/). The one that we're most inerested in is the home directory. That's where most of the files you'll use are stored. 



=== pwd (print working directory)

To find out your exact location in the filesystem, type 

[source,sh]
[subs=+quotes]
----
$ *pwd*
----
to obtain the path of your current working directory. Beginning with the root directory (*/*), below is the path of my home directory. 

[source,sh]
[subs=+quotes]
----
Dylans-Macbook-Pro:~ eljefe$ *pwd*
/Users/eljefe
----
[NOTE] 
====
The path of your home directory depends on your username and your operating system. But generally, it should like this: 

* macOS: `/Users/_username_`
* Linux-based OS: `/home/_username_`
* Windows: `C:\Users{backslash}__username__`
====
=== Absolute vs. relative paths

In the example above, pwd printed the absolute path of the current working directory. The path is called absolute because it can be accessed from anywhere within the filesystem. 

On the other hand, a relative path can only be accessed from the current working directory. With the following examples, this will make more sense. 

=== cd (change directories)

cd allows you to change directories. You can move to the root (*/*) directory by using *..* (called the parent directory, it moves you one level up) - type the following command twice and observe your promopt each time

[source,sh]
[subs=+quotes]
----
$ cd ..
----

Your prompt should now reflect your new working directory as root (*/*).

You can also use the following command to achieve the same result

[source,sh]
[subs=+quotes]
----
$ cd ../..
----

To reutrn to your home directory simply type

[source,sh]
[subs=+quotes]
----
$ *cd *
----

You can also return to specify the home directory in your path by typing

[source,sh]
[subs=+quotes]
----
$ cd ~
----

== Exercise 1: Adding options to commands

. Change directories from home to the directory *mydir*. 
+
[source,sh]
[subs=+quotes]
----
$ cd mydir/
----
+
. List the contents of mydir, first with `*ls*` then with `*ls -F*. The minus sign (-) is called a flag. Flags are used to add options. Options alter the output of a command.  
+
[source,sh]
[subs=+quotes]
----
$ *ls*
my-dir01	my-dir02	quotes1
$ *ls -F*
my-dir01/	my-dir02/	quotes1

----
+
The output is different the second time. The files that contain a slash (*/*) at the end of their name are directories.
+
. List the contents of another directory by specifying the path. Run `*ls -F mydir*`:
+
[source,sh]
[subs=+quotes]
----
$ *ls -F mydir*
my-dir01/        my-dir02/
----
+
[TIP]
.Features of the Shell
====
.. History: Press the up-arrow on your keyboard to recall previously entered commands. 
.. Auto-complete: Press the tab key on your keyboard when entering text in the command line. If the shell recognizes the name of a command, directory, or file, it'll fill out the rest!
====
+
[source,sh]
[subs=+quotes]
----
$ *ls mydir/my-dir01*
$ *ls mydir/my-dir02*
my_dir01/        my_dir02/
---- 
+ 
. Try running: 
+ 
[source,sh]
[subs=+quotes]
----
$ *cd my-dir02*
bash: cd: my-dir02: No such file or directory
---- 
+
. `No such file or directory` is a common error. When you receive this error, ask yourself: 
.. did I spell the file/directory name correctly?
.. did I utilize the correct path?
+
{zwsp} +
. So far all of the commands we have run are examples examples of *relative paths* (pathanmes that link us to our destination only from our current working directory). 

== Exercise 3: Listing content in the root directory

. *Absolute paths* link us to our destination regardless of our current working directory. An example of this is the the path of the root directory. Run `*ls /*`:
+
[source,sh]
[subs=+quotes]
----
$ *ls -F /*
----
+
[source,sh]
[subs=+quotes]
----
$ *ls -F*
----
. Look for a directory called `bin/` and list its content:
+
[source,sh]
[subs=+quotes]
----
$ *ls /bin*
----
+
. Do you see the file `ls*`? This is one of several locations where shell programs (commands) are stored. The asterick * means the files are *executable* (able to run in the command line). 

== Test yourself

*Problems*:

. For listing the content of `mydir-02`
.. what directory would we need to be in to run `*cd my-dir02*`?
.. What is the absolute path of `my-dir02`?
.. Why did the command `*cd mydir/mydir-02*` run even though we didn't specify an absolute path?
. In your home and root directories, Run `*ls*` with the following options and determine the effect that they have on the output:
.. `*ls -1*`
.. `*ls -a*`

*Answers*:

. For listing the content of `mydir-02`
.. Directory: `mydir/` 
.. Absolute path: `/Users/_username_/mydir/mydir-02` where the first slash `/` is the root directory.
.. The current working directory had the path name `/Users/_username_/mydir` which is linked to `mydir-02` (refer to ANSWER b.)
. In your home and root directories, Run `*ls*` with the following options and determine the effect that they have on the output:
.. list all the files, one per line
.. `ls -a` List all files, including hidden files: those that begin with dot (.)

CAUTION: hidden files shouldn't be messed with until you are more familiar with the command-line! 

== Common Errors

== Additional Resources

